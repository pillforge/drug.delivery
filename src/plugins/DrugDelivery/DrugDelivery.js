/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Oct 27 2015 13:49:24 GMT-0500 (CDT).
 */

define([
  'plugin/PluginConfig',
  'plugin/PluginBase',
  'module'
], function (
  PluginConfig,
  PluginBase,
  module) {
  'use strict';

  /**
   * Initializes a new instance of DrugDelivery.
   * @class
   * @augments {PluginBase}
   * @classdesc This class represents the plugin DrugDelivery.
   * @constructor
   */
  var DrugDelivery = function () {
    // Call base class' constructor.
    PluginBase.call(this);
  };

  // Prototypal inheritance from PluginBase.
  DrugDelivery.prototype = Object.create(PluginBase.prototype);
  DrugDelivery.prototype.constructor = DrugDelivery;

  /**
   * Gets the name of the DrugDelivery.
   * @returns {string} The name of the plugin.
   * @public
   */
  DrugDelivery.prototype.getName = function () {
    return 'DrugDelivery';
  };

  /**
   * Gets the semantic version (semver.org) of the DrugDelivery.
   * @returns {string} The version of the plugin.
   * @public
   */
  DrugDelivery.prototype.getVersion = function () {
    return '0.1.0';
  };

  /**
   * Main function for the plugin to execute. This will perform the execution.
   * Notes:
   * - Always log with the provided logger.[error,warning,info,debug].
   * - Do NOT put any user interaction logic UI, etc. inside this method.
   * - callback always has to be called even if error happened.
   *
   * @param {function(string, plugin.PluginResult)} callback - the result callback
   */
  DrugDelivery.prototype.main = function (callback) {
    var self = this;
    var nodeObject = self.activeNode;

    if (!self.core.isTypeOf(nodeObject, self.META.app) ) {
      return callback('Object is not an *app*', self.result);
    }

    self.core.loadChildren(nodeObject, function (err, children) {
      for (var i = children.length - 1; i >= 0; i--) {
        if (self.core.isTypeOf(children[i], self.META.uses)) {
          self.compileApp(children[i], function (err) {
            if (err) {
              return callback(err, self.result);
            }
            self.result.setSuccess(true);
            callback(null, self.result);
          });
        }
      }
    });

  };

  DrugDelivery.prototype.compileApp = function (uses_obj, callback) {
    var self = this;
    var async = require('async');
    var fs = require('fs');
    var path = require('path');

    async.series([
      function (callback) {
        self.core.loadPointer(uses_obj, 'src', callback);
      },
      function (callback) {
        self.core.loadPointer(uses_obj, 'dst', callback);
      }
    ],
    function (err, results) {
      if (err) {
        return callback(err);
      }
      var src_obj = results[0];
      var dst_obj = results[1];
      if (!self.core.isTypeOf(src_obj, self.META.schedule)) {
        return callback('Src is not a *schedule* type');
      }
      if (!self.core.isTypeOf(dst_obj, self.META.input)) {
        return callback('Dst is not an *input* type');
      }
      var parent_node = self.core.getParent(dst_obj);
      var parent_name = self.core.getAttribute(parent_node, 'name');

      var dirname = module.uri;
      var path_to_template = path.join(path.resolve(dirname), '../../../templates', parent_name);
      if (!fs.existsSync(path_to_template)) {
        return callback('no template for ' + parent_name);
      }
      self.getSchedule(src_obj, function (err, schedule) {
        if (err) {
          return callback(err);
        }
        // Save schedule and compile
        var header = self.saveHeader(schedule, path_to_template);
        callback();
      });
    });
  };

  DrugDelivery.prototype.saveHeader = function(schedule, file_path) {
    var fs = require('fs');
    var path = require('path');
    file_path = path.join(file_path, 'schedule_data.h');
    var s = '#define schedule_data_macro ';
    s += '{' + schedule.map(function (sch) {
      return '{' + sch[0] + ', ' + sch[1] + '}';
    }).join(', ') + '}';
    fs.writeFileSync(file_path, s);
  };

  DrugDelivery.prototype.getSchedule = function (schedule_obj, callback) {
    var self = this;
    var cache = {};
    var order = {};
    var schedule = [];
    var initial;
    self.core.loadChildren(schedule_obj, function (err, children) {
      for (var i = children.length - 1; i >= 0; i--) {
        var path = self.core.getPath(children[i]);
        cache[path] = children[i];
      }
      for (var i = children.length - 1; i >= 0; i--) {
        if (self.core.isTypeOf(children[i], self.META.time)) {
          var src = self.core.getPointerPath(children[i], 'src');
          var dst = self.core.getPointerPath(children[i], 'dst');
          var duration = self.core.getAttribute(children[i], 'duration');
          var amount = self.core.getAttribute(cache[dst], 'amount');
          order[src] = [dst, duration, amount];
        } else if (self.core.isTypeOf(children[i], self.META.start)) {
          initial = self.core.getPath(children[i]);
        }
        // else if (self.core.isTypeOf(children[i], self.META.release)) {
        // } else if (self.core.isTypeOf(children[i], self.META.end)) {
        // }
      }

      var curr = initial;
      while (order.hasOwnProperty(curr)) {
        duration = order[curr][1];
        amount = order[curr][2];
        curr = order[curr][0];
        if (amount) {
          schedule.push([duration, amount]);
        }
      }
      callback(null, schedule);
    });
  };

  return DrugDelivery;
});
