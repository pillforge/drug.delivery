/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Oct 27 2015 13:49:24 GMT-0500 (CDT).
 */

define([
  'plugin/PluginConfig',
  'plugin/PluginBase',
  'module'
], function (
  PluginConfig,
  PluginBase,
  module) {
  'use strict';

  /**
   * Initializes a new instance of DrugDelivery.
   * @class
   * @augments {PluginBase}
   * @classdesc This class represents the plugin DrugDelivery.
   * @constructor
   */
  var DrugDelivery = function () {
    // Call base class' constructor.
    PluginBase.call(this);
  };

  // Prototypal inheritance from PluginBase.
  DrugDelivery.prototype = Object.create(PluginBase.prototype);
  DrugDelivery.prototype.constructor = DrugDelivery;

  /**
   * Gets the name of the DrugDelivery.
   * @returns {string} The name of the plugin.
   * @public
   */
  DrugDelivery.prototype.getName = function () {
    return 'DrugDelivery';
  };

  /**
   * Gets the semantic version (semver.org) of the DrugDelivery.
   * @returns {string} The version of the plugin.
   * @public
   */
  DrugDelivery.prototype.getVersion = function () {
    return '0.1.0';
  };

  /**
   * Main function for the plugin to execute. This will perform the execution.
   * Notes:
   * - Always log with the provided logger.[error,warning,info,debug].
   * - Do NOT put any user interaction logic UI, etc. inside this method.
   * - callback always has to be called even if error happened.
   *
   * @param {function(string, plugin.PluginResult)} callback - the result callback
   */
  DrugDelivery.prototype.main = function (callback) {
    var self = this;
    var nodeObject = self.activeNode;

    var meta_types = ['app', 'uses', 'schedule', 'input', 'time', 'start', 'template_app'];
    var meta_complete = meta_types.every(function(e) {
      return self.META[e];
    });
    if (!meta_complete) {
      return callback('META definition is not complete', self.result);
    }

    if (!self.core.isTypeOf(nodeObject, self.META.app) ) {
      return callback('Object is not an *app*', self.result);
    }

    var template_app = '';
    self.core.loadChildren(nodeObject, function (err, children) {
      for (var i = children.length - 1; i >= 0; i--) {
        if (self.core.isTypeOf(children[i], self.META.template_app)) {
          var p_node = self.core.getBase(children[i]);
          template_app = self.core.getAttribute(p_node, 'name');
          break;
        }
      }
      switch(template_app) {
        case '':
          return callback('There\'s no template_app object in the sheet', self.result);
          break;
        case 'DrugDeliveryBase':
          self.core.loadChildren(nodeObject, function (err, children) {
            for (var i = children.length - 1; i >= 0; i--) {
              if (self.core.isTypeOf(children[i], self.META.uses)) {
                self.compileApp(children[i], function (err) {
                  if (err) {
                    return callback(err, self.result);
                  }
                  self.result.setSuccess(true);
                  callback(null, self.result);
                });
              }
            }
          });
          break;
        case 'DrugDeliveryMCR':
          self.compileMCR(nodeObject, callback);
          break;
        default:
          return callback('unknown issue: ' + template_app, self.result);
      }
    });

  };

  DrugDelivery.prototype.getChildrenObj = function(nodeObject, callback) {
    var self = this;
    var result = {
      'template_app': [],
      'uses': []
    };
    self.core.loadChildren(nodeObject, function (err, children) {
      if (err) {
        return callback(err);
      }
      for (var i = children.length - 1; i >= 0; i--) {
        if (self.core.isTypeOf(children[i], self.META.template_app)) {
          result['template_app'].push(children[i]);
        } else if (self.core.isTypeOf(children[i], self.META.uses)) {
          result['uses'].push(children[i]);
        }
      }
      return callback(null, result);
    });
  };

  DrugDelivery.prototype.compileMCR = function (nodeObject, callback) {
    var self = this;
    var path = require('path');
    var async = require('async');
    var fs = require('fs');
    var dirname = module.uri;

    var path_to_template = path.join(path.resolve(dirname), '../../../templates/DrugDeliveryMCR');
    if (!fs.existsSync(path_to_template)) {
      return callback('no template for ' + parent_name);
    }

    async.waterfall([
      function (callback) {
        self.getChildrenObj(nodeObject, callback);
      },
      function (app_children, callback) {
        if (app_children['template_app'].length != 1) {
          callback('There should be only 1 template_app in the sheet');
        }

        var macro_obj = {};
        async.each(app_children['uses'], function (uses, callback) {
          async.parallel([
            function (callback) {
              self.core.loadPointer(uses, 'src', callback);
            },
            function (callback) {
              self.core.loadPointer(uses, 'dst', callback);
            }
          ], function (err, results) {
            var src_obj = results[0];
            var dst_obj = results[1];
            var dst_name = self.core.getAttribute(dst_obj, 'name');
            if (dst_name != 'heartbeat') {
              return callback('Unknown input type');
            }
            var src_value = self.core.getAttribute(src_obj, 'value');
            macro_obj[dst_name] = src_value;
            callback();
          });
        }, function (err) {
          if (err) {
            return callback(err);
          }
          callback(null, macro_obj);
        });
      },
      function (macro_obj, callback) {
        self.saveHeaderMCR(macro_obj, path_to_template);
        self.compileAddArtifacts(path_to_template, callback);
      }
    ],
    function (err, result) {
      if (err) {
        return callback(err, self.result);
      }
      self.result.setSuccess(true);
      return callback(null, self.result);
    });

  };

  DrugDelivery.prototype.compileApp = function (uses_obj, callback) {
    var self = this;
    var async = require('async');
    var fs = require('fs');
    var path = require('path');

    async.series([
      function (callback) {
        self.core.loadPointer(uses_obj, 'src', callback);
      },
      function (callback) {
        self.core.loadPointer(uses_obj, 'dst', callback);
      }
    ],
    function (err, results) {
      if (err) {
        return callback(err);
      }
      var src_obj = results[0];
      var dst_obj = results[1];
      if (!self.core.isTypeOf(src_obj, self.META.schedule)) {
        return callback('Src is not a *schedule* type');
      }
      if (!self.core.isTypeOf(dst_obj, self.META.input)) {
        return callback('Dst is not an *input* type');
      }
      var parent_node = self.core.getParent(dst_obj);
      var parent_name = self.core.getAttribute(parent_node, 'name');

      var dirname = module.uri;
      var path_to_template = path.join(path.resolve(dirname), '../../../templates', parent_name);
      if (!fs.existsSync(path_to_template)) {
        return callback('no template for ' + parent_name);
      }
      self.getSchedule(src_obj, function (err, schedule) {
        if (err) {
          return callback(err);
        }
        // Save schedule and compile
        var header = self.saveHeader(schedule, path_to_template);
        self.compileAddArtifacts(path_to_template, callback);
      });
    });
  };

  DrugDelivery.prototype.compileAddArtifacts = function(path_to_template, callback) {
    var self = this;
    var path = require('path');
    var fs = require('fs');
    var execSync = require('child_process').execSync;
    var cmd = 'make exp430';
    try {
      execSync(cmd, {
        cwd: path_to_template,
        stdio: 'inherit'
      });
    } catch (err) {
      return callback(err);
    }
    var artifact = self.blobClient.createArtifact(path.basename(path_to_template));
    var path_to_build = path.join(path_to_template, 'build', 'exp430');
    var files = fs.readdirSync(path_to_build);
    var filesToAdd = {};
    files.forEach(function(file) {
      filesToAdd[file] = fs.readFileSync(path.join(path_to_build, file));
    });
    artifact.addFiles(filesToAdd, function (err, hashes) {
      artifact.save(function (err, hash) {
        self.result.addArtifact(hash);
        callback();
      });
    });
  };

  DrugDelivery.prototype.saveHeaderMCR = function(macro_obj, file_path) {
    var path = require('path');
    var fs = require('fs');
    file_path = path.join(file_path, 'drug_delivery_mcr.h');
    var s = '';
    for (var mac in macro_obj) {
      s += '#define ' + mac + ' ' + macro_obj[mac] + '\n';
    }
    fs.writeFileSync(file_path, s);
  };

  DrugDelivery.prototype.saveHeader = function(schedule, file_path) {
    var fs = require('fs');
    var path = require('path');
    file_path = path.join(file_path, 'schedule_data.h');
    var s = '#define schedule_data_macro ';
    s += '{' + schedule.map(function (sch) {
      return '{' + sch[0] + ', ' + sch[1] + '}';
    }).join(', ') + '}';
    fs.writeFileSync(file_path, s);
  };

  DrugDelivery.prototype.getSchedule = function (schedule_obj, callback) {
    var self = this;
    var cache = {};
    var order = {};
    var schedule = [];
    var initial;
    self.core.loadChildren(schedule_obj, function (err, children) {
      for (var i = children.length - 1; i >= 0; i--) {
        var path = self.core.getPath(children[i]);
        cache[path] = children[i];
      }
      for (var i = children.length - 1; i >= 0; i--) {
        if (self.core.isTypeOf(children[i], self.META.time)) {
          var src = self.core.getPointerPath(children[i], 'src');
          var dst = self.core.getPointerPath(children[i], 'dst');
          var duration = self.core.getAttribute(children[i], 'duration');
          var amount = self.core.getAttribute(cache[dst], 'amount');
          order[src] = [dst, duration, amount];
        } else if (self.core.isTypeOf(children[i], self.META.start)) {
          initial = self.core.getPath(children[i]);
        }
        // else if (self.core.isTypeOf(children[i], self.META.release)) {
        // } else if (self.core.isTypeOf(children[i], self.META.end)) {
        // }
      }

      var curr = initial;
      while (order.hasOwnProperty(curr)) {
        duration = order[curr][1];
        amount = order[curr][2];
        curr = order[curr][0];
        if (amount) {
          schedule.push([duration, amount]);
        }
      }
      callback(null, schedule);
    });
  };

  return DrugDelivery;
});
